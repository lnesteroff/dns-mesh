# 08-reconciler-cronjob.yaml
# This manifest deploys a CronJob that acts as a self-healing operator.
# It periodically checks if the Knot configuration is in sync with the
# catalog zone and automatically adds new peers if they are missing.

apiVersion: v1
kind: ServiceAccount
metadata:
  name: knot-reconciler-sa
  namespace: dns-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: knot-reconciler-role
  namespace: dns-system
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "list", "update", "patch"]
- apiGroups: ["apps"]
  resources: ["statefulsets"]
  verbs: ["get", "list", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: knot-reconciler-binding
  namespace: dns-system
subjects:
- kind: ServiceAccount
  name: knot-reconciler-sa
roleRef:
  kind: Role
  name: knot-reconciler-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: knot-reconciler
  namespace: dns-system
spec:
  # Run every 5 minutes
  schedule: "*/5 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: knot-reconciler-sa
          restartPolicy: OnFailure
          containers:
          - name: reconciler
            # This image provides the Python runtime and dependencies.
            # You must build the Dockerfile.reconciler and push it to a
            # registry that is accessible from all your sites.
            image: your-registry/knot-reconciler:latest
            volumeMounts:
            - name: knot-config-volume
              mountPath: /etc/knot/knot.conf
              subPath: knot.conf
            - name: reconciler-script
              mountPath: /app/reconcile.py
              subPath: reconcile.py
          volumes:
          - name: knot-config-volume
            configMap:
              name: knot-config
          - name: reconciler-script
            configMap:
              name: knot-reconciler-script
---
# Create a ConfigMap to hold the reconciler script itself.
# This allows you to update the script's logic without rebuilding the container image.
apiVersion: v1
kind: ConfigMap
metadata:
  name: knot-reconciler-script
  namespace: dns-system
data:
  reconcile.py: |
    # reconcile.py
    import dns.resolver
    import dns.zone
    import os
    import re
    import datetime
    from kubernetes import client, config
    from kubernetes.client.rest import ApiException

    # --- Configuration ---
    NAMESPACE = "dns-system"
    CONFIGMAP_NAME = "knot-config"
    STATEFULSET_NAME = "knot"
    CATALOG_ZONE_NAME = "catalog.internal.dns"
    ADDRESS_BOOK_ZONE_NAME = "dns.internal"
    KNOT_CONFIG_PATH = "/etc/knot/knot.conf"
    LOCAL_KNOT_SERVER = "127.0.0.1" # Query the local Knot instance

    def get_fqdn_from_address_book(base_name):
        """
        Queries the local server for a TXT record in the address book zone
        to find the FQDN of the primary server for a given zone base name.
        """
        try:
            query_name = f"{base_name}.{ADDRESS_BOOK_ZONE_NAME}"
            resolver = dns.resolver.Resolver()
            resolver.nameservers = [LOCAL_KNOT_SERVER]
            answer = resolver.resolve(query_name, 'TXT')
            # TXT records are quoted, so we strip the quotes.
            return answer[0].to_text().strip('"')
        except Exception as e:
            print(f"Could not resolve TXT record for {query_name}: {e}")
            return None

    def get_desired_remotes_from_catalog():
        print(f"Attempting AXFR of {CATALOG_ZONE_NAME} from {LOCAL_KNOT_SERVER}...")
        try:
            zone = dns.zone.from_xfr(dns.query.xfr(LOCAL_KNOT_SERVER, CATALOG_ZONE_NAME, timeout=10), relativize=False)
            desired_remotes = {}
            for name, node in zone.nodes.items():
                name_str = str(name).replace("." + CATALOG_ZONE_NAME + ".", "")
                if name_str == "version" or name_str == "@" or not node.rdatasets:
                    continue
                for rdataset in node.rdatasets:
                    if rdataset.rdtype == dns.rdatatype.PTR:
                        for item in rdataset.items:
                            zone_name = str(item).rstrip('.')
                            base_name = zone_name.split('.')[0]
                            remote_id = f"{base_name}-remote"
                            
                            # Discover the FQDN from the address book zone
                            fqdn = get_fqdn_from_address_book(base_name)
                            if fqdn:
                                desired_remotes[remote_id] = fqdn
                            else:
                                print(f"Warning: Found zone '{zone_name}' in catalog but could not find its FQDN in the address book.")

            print(f"Found desired remotes in catalog: {list(desired_remotes.keys())}")
            return desired_remotes
        except Exception as e:
            print(f"Error during AXFR of catalog zone: {e}")
            print("This can be expected if the local Knot server is not yet ready. Exiting gracefully.")
            exit(0)

    def get_current_remotes_from_config():
        if not os.path.exists(KNOT_CONFIG_PATH):
            print(f"Error: Knot config file not found at {KNOT_CONFIG_PATH}")
            return None
        with open(KNOT_CONFIG_PATH, 'r') as f:
            content = f.read()
        remotes = set()
        remote_section_match = re.search(r'remote:(.*?)(\w+:|$)', content, re.DOTALL)
        if remote_section_match:
            remote_section = remote_section_match.group(1)
            ids = re.findall(r'-\s+id:\s+(\S+)', remote_section)
            remotes.update(ids)
        print(f"Found current remotes in config: {list(remotes)}")
        return remotes

    def generate_new_config(new_remotes):
        print(f"Generating new config to add remotes: {list(new_remotes.keys())}")
        with open(KNOT_CONFIG_PATH, 'r') as f:
            config_str = f.read()
        
        remote_insertion_point = re.search(r'(remote:.*?)(\n\S|$)', config_str, re.DOTALL).end(1)
        
        new_blocks = ""
        for remote_id, fqdn in new_remotes.items():
            new_blocks += (
                f"\n      - id: {remote_id}\n"
                f"        address: {fqdn}@853\n"
                f"        key: xfr-key\n"
                f"        quic: on"
            )
        
        config_str = config_str[:remote_insertion_point] + new_blocks + config_str[remote_insertion_point:]

        new_remote_ids_str = ", ".join(new_remotes.keys())
        def append_to_list(list_name, content):
            pattern = re.compile(f"({list_name}:\s*\[[^\]]*")(\])")
            return pattern.sub(f"\1, {new_remote_ids_str}\2", content)

        config_str = append_to_list(r"remote: \[catalog-primary-remote", config_str)
        config_str = append_to_list(r"master: \[catalog-primary-remote", config_str)
        
        return config_str

    def main():
        print("--- Starting Knot Config Reconciler ---")
        try:
            config.load_incluster_config()
            api = client.CoreV1Api()
            apps_api = client.AppsV1Api()
            print("Successfully loaded in-cluster Kubernetes config.")
        except Exception as e:
            print(f"Error loading Kubernetes config: {e}")
            return

        desired_remotes = get_desired_remotes_from_catalog()
        current_remotes = get_current_remotes_from_config()

        if desired_remotes is None or current_remotes is None:
            print("Could not determine desired or current state. Exiting.")
            return

        missing_remotes_ids = set(desired_remotes.keys()) - current_remotes
        if not missing_remotes_ids:
            print("Configuration is up to date. No changes needed.")
            return

        print(f"Configuration is stale. Missing remotes: {list(missing_remotes_ids)}")
        remotes_to_add = {k: v for k, v in desired_remotes.items() if k in missing_remotes_ids}
        new_knot_conf = generate_new_config(remotes_to_add)

        try:
            print(f"Fetching ConfigMap '{CONFIGMAP_NAME}'...")
            cm = api.read_namespaced_config_map(name=CONFIGMAP_NAME, namespace=NAMESPACE)
            if cm.data["knot.conf"] == new_knot_conf:
                print("ConfigMap is already up to date. No changes needed.")
                return
            cm.data["knot.conf"] = new_knot_conf
            print(f"Updating ConfigMap '{CONFIGMAP_NAME}'...")
            api.replace_namespaced_config_map(name=CONFIGMAP_NAME, namespace=NAMESPACE, body=cm)
            print("ConfigMap updated successfully.")
        except ApiException as e:
            print(f"Error updating ConfigMap: {e}")
            return

        try:
            print(f"Triggering rolling restart of StatefulSet '{STATEFULSET_NAME}'...")
            patch = {"spec": {"template": {"metadata": {"annotations": {"reconciler/restartedAt": datetime.datetime.utcnow().isoformat()}}}}}}
            apps_api.patch_namespaced_stateful_set(name=STATEFULSET_NAME, namespace=NAMESPACE, body=patch)
            print("StatefulSet restart triggered successfully.")
        except ApiException as e:
            print(f"Error restarting StatefulSet: {e}")
            return

        print("--- Reconciler finished successfully ---")

    if __name__ == "__main__":
        main()
